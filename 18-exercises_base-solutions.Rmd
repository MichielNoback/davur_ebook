# Exercise solutions

```{r exercise-sol-setup, include=FALSE}
#this is for rounding numbers in this session
options(digits=3)
knitr::opts_knit$set(cache = TRUE,
                     tidy = TRUE,
                     tidy.opts = list(blank = FALSE, width.cutoff = 60))
library(ggplot2)
library(tidyr)
library(dplyr)
library(lubridate)
```

## Getting started

### Install the tools

No solution for this one.


## The toolbox

### Customize RStudio

No solution for this one.


### Résumé

No solution for this one.


## Basic R

### Math in the console

```{r results = 'hold'}
31 + 11
66 - 24
126 / 3
12^2 
256**0.5
(3 * (4 + 8^0.5))/(5^3)
```


### Functions (I)

**A**  
Answer: `paste()` and `paste0()`. The difference lies in the _separator_, which is an empty string in `paste0()` and one space in `paste()`. Moreover, the separator can be configured in `paste()` using the `sep = ` parameter.

```{r paste-ex-1, eval = FALSE}
paste("welcome ", "to ", "R", sep = "")
paste0("welcome ", "to ", "R")
```

**B**  
Answer: `abs()` returns the _absolute_ value. Simply put, a number with the minus sign removed if present.

```{r abs-ex-1}
abs(-20)
abs(20)
```

**C**  
Answer: it combines (**c**oncatenates) its arguments into a single vector. The first example creates a "character" (text data) and the second a "numeric" (numeric data).

```{r c-ex-1}
c(1, 2, "a")
class(c(1, 2, "a"))
c(1, 2, 3)
class(c(1, 2, 3))
```


**D**  

```{r install-packages-demo-1, eval = FALSE}
#install it. Note the quotes
install.packages("RColorBrewer")
#load it into your session. Note the absence of quotes
library(RColorBrewer)
```

**E**  

```{r rounding-numberz-a, eval = FALSE}
ceiling(numberz)
trunc(numberz) # or signif(numberz, 3)
round(numberz, 3)
floor(numberz)
```

**F**  

```{r convert-names-a, eval = FALSE}
strsplit(names, " ")
```

**G**  

```{r find-correct-a, eval = FALSE}
unique(birds)
```

### Variables

```{r variables-ex-1, eval = FALSE}
x <- 20
y <- 10
z <- 3

x + y
x^z
#OR
#x**z
q <- x * y * z
sqrt(q)
q/pi
log10(x * y)
```

### Vectors

#### Circles {-}

The circumference of a circle is $2\pi\cdot r$, its surface $4\pi \cdot r^2$ and its volume $4/3 \pi\cdot r^3$.
Given this vector of circle radiuses,

```{r radiuses-defined2, eval = FALSE}
radiuses <- c(0, 1, 2, pi, 4)
```

**A**  
Calculate their cirumference.

```{r circle-circumference, eval = FALSE}
2 * pi * radiuses
```

**B**  
Calculate their surface.

```{r circle-surface, eval = FALSE}
4 * pi * radiuses^2
```

**C**  
Calculate their volume.

```{r circle-volume, eval = FALSE}
4/3 * pi * radiuses^3
```

#### Creating vectors {-}

Create the following vectors, as efficiently as possible. The functions `rep()`, `seq()` and `paste0()` and the colon operator `:` can be used, in any combination.


**A**   
`[1] 1 2 5 1 2 5`

```{r create-vector-A, eval = FALSE}
rep(c(1, 2, 5), times = 2)
```


**B**  
`[1] 9 9 9 8 8 8 7 7 7 6 6 6 5 5 5`

```{r create-vector-B, eval = FALSE}
rep(9:5, each = 3)
```

**C**  
` [1] 1 1 1 4 4 4 9 9 9 1 1 1 4 4 4 9 9 9`

```{r create-vector-C, eval = FALSE}
rep(c(1, 4, 9), times = 2, each = 3)
```

**D**  
` [1] "1a" "2b" "3c" "4d" "5e" "1a" "2b" "3c" "4d" "5e"`

```{r create-vector-D, eval = FALSE}
rep(paste0(1:5, letters[1:5]), times = 2)
```

**E**  
`[1] "0z"   "0.2y" "0.4x" "0.6w" "0.8v" "1u"`

```{r create-vector-E, eval = FALSE}
paste0(seq(from = 0, to = 1, length.out = 6), letters[26:21])
```

**F**  
`[1] "505" "404" "303" "202" "101" "000"`
```{r create-vector-F, eval = FALSE}
paste0(5:0, 0, 5:0)
```

**G [Challenge]**  
`[1] "0.5A5.0" "0.4B4.0" "0.3C3.0" "0.2D2.0" "0.1E1.0"`

```{r create-vector-G, eval = FALSE}
paste0(seq(from = 0.5, to = 0.1, by = -0.1),  LETTERS[1:5], 5:1, ".0")
```


## Complex datatypes

### Creating factors

**A**  
```{r animal-risk-a, eval = FALSE}
animal_risk <- c(2, 4, 1, 1, 2, 4, 1, 4, 1, 1, 2, 1)
animal_risk_factor <- factor(x = animal_risk,
                             levels = c(1, 2, 3, 4),
                             labels = c("harmless", "risky", "dangerous", "deadly"),
                             ordered = TRUE)
```

**B**  
```{r wealth-sim-a}
set.seed(1234)
wealth_male <- sample(x = letters[1:4], 
                 size = 1000,
                 replace= TRUE, 
                 prob = c(0.7, 0.17, 0.12, 0.01))
wealth_female <- sample(x = letters[1:4], 
                 size = 1000,
                 replace= TRUE, 
                 prob = c(0.8, 0.15, 0.497, 0.003))

wealth_labels <- c("poor", "middle class", "wealthy", "rich")

wealth_male_f <- factor(x = wealth_male,
                        levels = letters[1:4],
                        labels = wealth_labels,
                        ordered = TRUE)

wealth_female_f <- factor(x = wealth_female,
                        levels = letters[1:4],
                        labels = wealth_labels,
                        ordered = TRUE)

#combine
wealth_all_f <- c(wealth_male_f, wealth_female_f)

prop.table(table(wealth_all_f)) * 100

```

### List actions

**A**  

```{r house-admin-a1, eval=FALSE}
house_admin[1]
```

**B**  

```{r house-admin-a2, eval=FALSE}
house_admin[2]
#OR
house_admin$Rose
```

**C**  

```{r house-admin-a3, eval=FALSE}
house_admin[1:2]
```

**D**  

```{r house-admin-a4, eval=FALSE}
house_admin$Mike$cooking
#OR
house_admin$Mike[[1]]
#OR
house_admin[[3]][["cooking"]]
#MORE POSSIBILITIES
```


**E**

```{r house-admin-a5, eval = FALSE}
house_admin$John$tasks[2]
#MANY MORE POSSIBILITIES
```



### Named vectors

**A**    
```{r named-vector-a1}
codons <- c("G", "P", "K", "S")
names(codons) <- c("GGA", "CCU", "AAA", "AGU")

my_DNA <- "GGACCUAAAAGU"
my_prot <- ""
for (i in seq(from = 1, to = nchar(my_DNA), by = 3)) {
        codon <- substr(my_DNA, i, i+2)
        my_prot <- paste0(my_prot, codons[codon])
}
print(my_prot)
```

**B**    
```{r named-vector-a2, eval = F}
nuc_weights <- c(491.2, 467.2, 507.2, 482.2)
names(nuc_weights) <- c('A', 'C', 'G', 'U')

mol_weight <- 0
for (i in 1:nchar(my_DNA)) {
        nuc <- substr(my_DNA, i, i);
        print(nuc)
        mol_weight <- mol_weight + nuc_weights[nuc]
}
mol_weight
```


### Lowry


```{r lowry-bsa-a, eval = FALSE}
bsa_conc <- c(0,	0,	0.025,	0.025,	0.075,	0.075,	0.125,	0.125)
```


```{r lowry-od-a, eval = FALSE}
OD750 <- c(0.063,	0.033,	0.16,	0.181,	0.346,	0.352,	0.491,	0.488)
```

**A**  

```{r lowry-dataframe-a, eval = FALSE}
dilution <- data.frame(bsa_conc, OD750)
```

**B**  

```{r lowry-names-a, eval = FALSE}
names(dilution) <- c("prot_conc", "absorption")
```

**C**  

```{r lowry-new-data-a, eval = FALSE}
bsa_conc2 <- c(0.175,	0.175,	0.25,	0.25)
OD750_2 <- c(0.597,	0.595,	0.743,	0.742)
```


```{r lowry-new-df-a, eval = FALSE}
df_temp <- data.frame("prot_conc" = bsa_conc2,
                      "absorption" = OD750_2)
```

**D**  

```{r lowry-new-data-rbind-a, eval = FALSE}
dilution <- rbind(dilution, df_temp)
```


**E**  

```{r lowry-cbind-a, eval = FALSE}
even <- dilution[c(T, F), ]
odd <- dilution[c(F, T), ]
dilution_duplo <- cbind(odd, even)
dilution_duplo
```

**F**  

```{r lowry-names-change-a, eval = FALSE}
dilution_duplo[, 3] <- NULL
names(dilution_duplo) <- c("prot_conc", "abs1", "abs2")
dilution_duplo
```

**G**  

```{rlowry-duplo-mean-a, eval = FALSE}
dilution_duplo$mean <- (dilution_duplo$abs1 + dilution_duplo$abs2) / 2
dilution_duplo
```


### Island surfaces

**A**  

```{r islands-dataframe-a, eval = FALSE}
islands_df <- data.frame(Island = names(islands),
                        Area = islands)
rownames(islands_df) <- NULL
islands_df
```


**B**  

```{r islands-order-a, eval=FALSE}
islands_df[order(islands_df$Area, decreasing = TRUE)[1:3], ]
#OR
islands_df[order(islands_df$Area, decreasing = TRUE), ][1:3,]
```

### USArrests 

The `USArrests` dataset is also one of the datasets included in the `datasets` package. It has info on the fifty states for these variables:

```
Murder arrests (per 100,000)
Assault arrests (per 100,000)
UrbanPop Percent urban population
Rape arrests (per 100,000)
```

We'll explore this dataset for a few questions.

**A**  

```{r usarrests-montana-a, eval=FALSE}
USArrests[rownames(USArrests) == "Montana", ]
```


**B**  

```{r usarrests-high-rape-a, eval=FALSE}
USArrests[USArrests$Rape == max(USArrests$Rape), ]
```


**C**  

```{r usarrests-compare-a, eval=FALSE}
USArrests[USArrests$Assault < USArrests$Murder * 10, ]
```


### File reading practice


**File 01**  

```{r file-reading-parctice-1, eval = FALSE}
my_dir <- "data/file_reading"
my_file <- "file01.txt"
my_path <- paste0(my_dir, "/", my_file)
my_data <- read.table(
    my_path,
    comment.char = "#",
    header = T,
    sep = ",",
    dec = ".",
    na.strings = "ND",
    as.is = c(1, 3))
```

**File 02**  

```{r file-reading-parctice-2, eval = FALSE}
my_file <- "file02.txt"
my_path <- paste0(my_dir, "/", my_file)
my_data <- read.table(
    my_path,
    comment.char = "$",
    header = T,
    sep = "\t",
    dec = ",",
    na.strings = "?",
    as.is = c(1, 3)
)
```

**File 03**  

```{r file-reading-parctice-3, eval = FALSE}
my_file <- "file03.txt"
my_path <- paste0(my_dir, "/", my_file)
my_data <- read.table(
    my_path,
    header = T,
    sep = ";",
    dec = ".",
    na.strings = "ND",
    as.is = c(1, 3)
)
```

**File 04**  

```{r file-reading-parctice-4, eval = FALSE}
my_file <- "file04.txt"
my_path <- paste0(my_dir, "/", my_file)
my_data <- read.table(
    my_path,
    header = T,
    sep = "\t",
    dec = ",",
    na.strings = "no data",
    as.is = c(1, 3)
)
```

**File 05**  

```{r file-reading-parctice-5, eval = FALSE}
my_file <- "file05.txt"
my_path <- paste0(my_dir, "/", my_file)
my_data <- read.table(
    my_path,
    comment.char = "#",
    header = T,
    sep = ";",
    dec = ".",
    na.strings = "ND",
    as.is = c(1, 3)
)
```

**File 06**  

```{r file-reading-parctice-6, eval = FALSE}
my_file <- "file06.txt"
my_path <- paste0(my_dir, "/", my_file)
my_data <- read.table(
    my_path,
    comment.char = "#",
    header = T,
    sep = ",",
    dec = ".",
    na.strings = "-",
    as.is = c(1, 3))
my_data
```

**File 07**  

```{r file-reading-parctice-7, eval = FALSE}
my_file <- "file07.txt"
my_path <- paste0(my_dir, "/", my_file)
my_data <- read.table(
    my_path,
    comment.char = "#",
    header = F,
    sep = ";",
    dec = ".",
    na.strings = "-",
    as.is = c(1, 3))
```

**File 08**  

```{r file-reading-parctice-8, eval = FALSE}
my_file <- "file08.txt"
my_path <- paste0(my_dir, "/", my_file)
my_data <- read.table(
    my_path,
    comment.char = "@",
    header = T,
    sep = ";",
    dec = ".",
    na.strings = "ND",
    as.is = c(1, 3))
```

(More files, but solutions omitted.)


## Basics of the `ggplot2` package

### Trees

With the `trees` dataset from the datasets package, create a scatter plot according to these constraints.

- x-axis: Height
- y-axis: Girth
- size of plot symbol: Volume
- color of plot symbol: darkgreen
- a smoother without error margins

NB: Where you specify aesthetics matters here!

As extra practice you could convert the values to the metric system first.

```{r trees-plot-a}
ggplot(data = trees,
       mapping = aes(x = Height, y = Girth)) +
  geom_point(aes(size = Volume), color = "darkgreen") +
  geom_smooth(method = "loess", se = FALSE, formula = y~x) +
  labs(x = "Height (ft)", y = "Girth (inches)")
```

### Insect Sprays 

The `datasets` package that is shipped with R has a dataset called `?`. Type `?InsectSprays` to get information on it. 

**A [&#10059;]**  

```{r insect-sprays-A, fig.asp=0.7, out.width='80%', fig.align='center', fig.cap = "The counts of insects in agricultural experimental units treated with different insecticides"}
ggplot(data = InsectSprays, 
       mapping = aes(x = spray, y = count)) +
    geom_boxplot() +
    ylab("Insect count") +
    xlab("Insect spray")
```

**B [&#10059;&#10059;]**  


```{r insect-sprays-B, fig.asp=0.7, out.width='80%', fig.align='center', fig.cap = "The counts of insects in agricultural experimental units treated with different insecticides"}
ggplot(data = InsectSprays, 
       mapping = aes(x = spray, y = count, color = spray)) +
    geom_jitter(height = 0, width = 0.1, shape = 18, size = 2, alpha = 0.7) +
    ylab("Insect count") +
    xlab("Insect spray")
```


### Pharmacokinetics

The `Theoph` dataset contains pharmacokinetics of theophylline, the anti-asthmatic drug theophylline. Twelve subjects were given oral doses of theophylline, then serum concentrations were measured at 11 time points over the next 25 hours.


**A**  

```{r theoph-decay-1}
ggplot(data = Theoph,
       mapping = aes(x = Time, y = conc, color = Dose, linetype = Subject)) +
  geom_line() +
  labs(x = "Time (h)", y = "Concentration (mg/l)")
```

**B**  

```{r theoph-decay-2}
ggplot(data = Theoph,
       mapping = aes(x = Time, y = conc)) +
  geom_line(aes(group = Subject, color = Dose)) +
  scale_color_gradient(low = "green", high = "red") +
  labs(x = "Time (h)", y = "Concentration (mg/l)") +
  theme_minimal()
```

(Many more solutions possible)


### USArrests (II)

**A**  

```{r ggplot-usarrests-scatter-a}
ggplot(data = USArrests,
       mapping = aes(x = Assault,
                     y = Murder)) +
  geom_point(color = "darkgreen") +
  geom_smooth(method = "lm", formula = y~x, se = FALSE, color = "darkred") +
  labs(x = "Assault arrests (per 100,000)", y = "Murder arrests (per 100,000)")
```

**B**  

```{r ggplot-usarrests-hist-dens-a}
scale <- 1
ggplot(data = USArrests,
       mapping = aes(x = Assault)) +
  geom_histogram(aes(y=..density..), fill = "lightblue", color = "black", bins = 30) +
  geom_density(color = "darkblue") +
  #scale_y_continuous(sec.axis = sec_axis(~ . * scale, name="Assault prob")) +
  labs(x = "Assault arrests (per 100,000)")
```


### Orchard Sprays

**A**  

```{r orchard-sprays-1-a}
ggplot(data = OrchardSprays,
       mapping = aes(x = treatment, y = decrease)) +
  geom_boxplot() +
  geom_jitter(color = "darkred", width = 0.2, alpha = 0.7)
```

**B**  

```{r orchard-sprays-2-a}
ggplot(data = OrchardSprays,
       mapping = aes(x = treatment, y = decrease)) +
  geom_violin(aes(fill=treatment))
```

### Diauxic growth 

**A [&#10059;&#10059;]**  

```{r diauxic-growth-A}
remote <- "https://raw.githubusercontent.com/MichielNoback/datasets/master/diauxic_growth/monod_diauxic_growth.csv"
#local <- "../diauxic.csv"
#download.file(url = remote, destfile = local)
diauxic <- read.table(remote, sep = ";", header = T)
diauxic <- pivot_longer(data = diauxic,
                        cols = -1,
                        names_to = "Substrate",
                        values_to = "OD")
```

**B [&#10059;]**  

```{r diauxic-growth-B}
diauxic$Substrate <- factor(diauxic$Substrate, 
       levels = c("GlucMann", "GlucXyl", "GlucArab", "GlucRham"), 
       labels = c("Glucose Mannose", "Glucose Xylose", "Glucose Arabinose", "Glucose Rhamnose"))
```

**C [&#10059;&#10059;]**  

Create a line plot with all four growth curves within a single graph.

```{r diauxic-growth-C, fig.asp=0.7, out.width='80%', fig.align='center', warning = FALSE, fig.cap = "Monod's Diauxic shift experiment."}
ggplot(data = diauxic,
       mapping = aes(x = Time, y = OD, color = Substrate)) +
    geom_point() +
    stat_smooth(method = "loess", se = FALSE, span = 0.3) +
    theme_bw()
```


**D [&#10059;&#10059;&#10059;]**  

```{r diauxic-growth-D, fig.asp=0.7, out.width='80%', fig.align='center', warning = FALSE, fig.cap = "Monod's Diauxic shift experiment."}
ggplot(data = diauxic,
       mapping = aes(x = Time, y = OD)) +
    geom_point() +
    stat_smooth(method = "loess", se = FALSE, span = 0.3) +
    facet_wrap(. ~ Substrate, nrow = 2) +
    theme_bw()
```


### Virginia Death Rates

```{r VADeaths-prep-rep}
library(dplyr)
## %>% is used to pipe results from one operation to the other, just like '|' in Linux.
virginia_death_rates <- as_tibble(VADeaths)
virginia_death_rates <- virginia_death_rates %>% 
    mutate("Age Group" = factor(rownames(virginia_death_rates), ordered = TRUE)) %>% 
    select(`Age Group`, everything()) #reorder the columns
```

**A (&#10059;&#10059;&#10059;)**  

Pivot this table to long (tidy) format. This should generate a dataframe with four columns: `Age Group`, `Habitat`, `Gender` and `DeathRate`.

```{r VADeaths-A, results = 'hide'}
virginia_death_rates <- virginia_death_rates %>% pivot_longer(cols = -1, 
                 names_to = c("Habitat", "Gender"), 
                 names_sep = " ", 
                 values_to = "DeathRate")
```

**B (&#10059;&#10059;)**  


```{r VADeaths-B, fig.asp=0.7, out.width='70%', fig.align='center', fig.cap="Virginia Death rates"}
ggplot(data = virginia_death_rates, aes(Gender)) +
    geom_bar(aes(weight = DeathRate, fill = Habitat), position = "dodge")
```

### Global temperature

Load the data.

```{r global-temp-load-a}
remote_file <- "https://raw.githubusercontent.com/MichielNoback/datasets/master/global_temperature/annual.csv"
global_temp <- read.table(remote_file,
                          header = TRUE,
                          sep = ",")
```

#### Create a scatter-and-line-plot [&#10059;&#10059;]

```{r scatter-global-temp, fig.asp=0.7, out.width='80%', fig.align='center', fig.cap="Global temperature anomalies"}
ggplot(data = global_temp,
       mapping = aes(x = Year, y = Mean, color = Source)) +
    geom_point(size = 0.5) +
    geom_line() +
    geom_smooth(se = FALSE, method = "loess", formula = 'y ~ x') +
    theme_bw()
```

#### Re-create the heatmap [&#10059;&#10059;&#10059;]

```{r heatmap-global-temp, fig.asp=0.3, out.width='80%', fig.align='center', fig.cap="Global temperature anomalies"}
ggplot(data = global_temp[global_temp$Source == "GCAG", ],
       mapping = aes(x = Year, y = 1)) +
    geom_tile(aes(fill = Mean), colour = "white") + 
    scale_fill_gradient2(low = "blue", mid = "white", high = "red") +
    theme_bw() +
    theme(axis.text.y = element_blank(), axis.ticks.y = element_blank(), axis.title.y = element_blank())
```

Note: rescaling the temperature from 0 to 1 may yield even better results.

#### Extra practice  
**Level: [&#10059;&#10059;]**  

No solutions for this one.  

### Investigate new visualization 
**Level: &#10059;&#10059;  

This assignment has no solution of course. It is included here solely to keep the numbering consistent for both assignment chapters.


## Functions (II)

### `cut()`  

```{r usarrests-factor-a, eval=FALSE}
USArrests$UrbanPop_f <- cut(USArrests$UrbanPop, 
                  breaks = c(0, 60, 80, 100),
                  labels = c("low", "mid", "high"),
                  right = FALSE)

table(USArrests$UrbanPop_f)
```

### `quantile()` 

**A**  

```{r quantile-precip-a}
precip[precip < quantile(precip, probs = 0.1)]
```

**B**  

```{r infert-quantile-a, eval = FALSE}
sel_range <- quantile(infert$age, probs = c(0.4, 0.6))
infert[infert$age > sel_range["40%"] & infert$age < sel_range["60%"], ]
```


## Flow control and scripting

### Illegal reproductions

#### The mean {-}

```{r, eval = FALSE}
my_mean <- function(x) {
        sum(x, na.rm = T) / length(x)
}
``` 

#### Standard deviation {-}

```{r, eval = FALSE}
my_sd <- function(x) {
        sqrt(sum((x - mean(x))^2)/(length(x)-1))
}
```

#### Maximum {-}

```{r, eval = FALSE}
set.seed(123) 
my_nums <- sample(10000, 1000)
my_max <- function(x) {
    max_val <- 0
    for (i in my_nums) {
        if (i > max_val) {
            max_val = i
        }
    }
    return(max_val)
}
```


#### Median {-}     

```{r, eval = FALSE}
my_median <- function(x) {
        sorted <- sort(x)
        if(length(x) %% 2 == 1) {
                #uneven length
                my_median <- sorted[ceiling(length(x)/2)]
        } else {
                my_median <- (sorted[length(x)/2] + sorted[(length(x)/2)+1]) / 2
        }
        return(my_median)
}
```


### Various other functions  


#### Find match locations {-}

```{r, eval = FALSE}
where_is_it <- function(x, look_for) {
    found <- integer(0)
    for (i in 1:length(x)) {
        elmnt <- x[i]
        if (elmnt == look_for) {
            found <- c(found, i)
        }
    }
    return(found)
}
x <- c("Pro", "Glu", "Lys", "Pro", "Ser")
where_is_it(x, "Pro")
##expected:
#[1] 1 4
```



#### Odd and even {-}

```{r, eval = FALSE}
count_odd_even <- function(x) {
    evens <- sum(x %% 2 == 0)
    odds <- sum(x %% 2 == 1)
    #OR, more efficient
    #odds <- length(x) - evens
    tmp <- c(even = evens, odd = odds)
    return(tmp)
}
count_odd_even(c(1,2,3,4,5,5))
```


#### Add column compared to mean {-}

```{r, eval = FALSE}
add_compared_to_mean <- function (df, name) {
    if (! is.data.frame(df)) {
        stop(paste0("'", df, "' is not a dataframe."))
    }
    if(! name %in% colnames(df)) {
        stop(paste0("'", name, "' is not an existing column."))
    }
    if(! is.numeric(df[, name])) {
        stop(paste0("'", name, " is not a numeric column."))
    }
    the_col <- df[, name]
    tmp <- ifelse(the_col > mean(the_col), "greater", "less")
    df$compared_to_mean <- tmp
    return(df)
}
my_df <- data.frame(a = c(2, 4, 2, 3, 4, 3, 1, 5), b = rep(c("x", "y"), 4))
add_compared_to_mean(my_df, "a")
```



#### Interquantile ranges {-}

```{r, eval = FALSE}
interquantile_range <- function(x, lower = 0, upper = 1) {
  if (! is.numeric(x) | 
      ! is.numeric(lower) |
      ! is.numeric(upper)) {
    stop("all three arguments should be numeric")
  }
  lower_val <- quantile(x, probs = lower)
  upper_val <- quantile(x, probs = upper)
  tmp <- upper_val - lower_val
  #a named vector is always nice, for acces but also for display purposes
  names(tmp) <- paste0(lower*100, "-", upper*100, "%")
  tmp
}
tst <- rnorm(1000)
interquantile_range(tst) # 0 to 1
interquantile_range(tst, 0.25, 0.75) # custom
#interquantile_range("foo") # error!
```


#### Vector distance {-}

```{r vector-distance, eval = FALSE}
distance <- function(p, q) {
    if (! is.numeric(p) | ! is.numeric(q)) {
        stop("non-numeric vectors passed")
    }
    if (length(p) != length(q)) {
        stop("vectors have unequal length")
    }
    sqrt(sum((p - q)^2))
}
```


#### Other distance measures {-}


```{r other-distance-measures, eval = FALSE}
my_distance <- function(p, q, method = "euclidean") {
  if (! (is.numeric(p) & is.numeric(q))) {
    stop("One or both of the vectors is not numeric")
  }
  if (length(p) != length(q)) {
    stop("Vectors are not of equal length")
  }
  if (method == "euclidean") {
    return(sqrt(sum((p - q)^2)))
  }
  else if (method == "manhattan") {
    return(sum(abs(p-q)))
  }
  else {
    stop(paste0("Method not found: ", method))
  }
}
my_distance(c(0,0,0), c(1, 1, 1))
```


#### G/C percentage {-}

```{r gc-percenatge-a, eval = FALSE}
GC_perc <- function(seq, strict = TRUE) {
  if (is.na(seq)) {
    return(NA)
  }
  if (length(seq) == 0) {
    return(0)
  }
  seq.split <- strsplit(seq, "")[[1]]
  gc.count <- 0
  anom.count <- 0
  for (n in seq.split) {
    if (length(grep("[GATUCgatuc]", n)) > 0) {
      if (n == "G" || n == "C") {
        gc.count <- gc.count + 1
      }
    } else {
      if (strict) {
        stop(paste("Illegal character", n))
      } else {
        anom.count <- anom.count + 1     
      }
    }
  }
  ##return perc
  ##print(gc.count)
  if (anom.count > 0) {
    anom.perc <- anom.count / nchar(seq) * 100
    warning(paste("Non-DNA characters have percentage of", anom.perc))
  }
  return(gc.count / nchar(seq) * 100)
}
```


## Tidying dataframes using Package tidyr

### Small examples

The [`data`](data/) folder of this eBook contains three small csv files that need tidying. Read them from file and convert them into tidy format, with data columns as clean as possible (e.g. not "creatine_T0" but "T0").

**A**  

Tidy file [`untidy1.csv`](data/untidy1.csv).

```{r untidy-1-a, eval = FALSE}
untidy1 <- read.table("data/untidy1.csv", 
                      sep = ",", 
                      header = TRUE)
pivot_wider(data = untidy1,
            names_from = type,
            values_from = value)
```


**B**  

Tidy file [`untidy2.csv`](data/untidy2.csv).

```{r untidy-2-a, eval = FALSE}
untidy2 <- read.table("data/untidy2.csv", 
                      sep = ",", 
                      header = TRUE)
pivot_longer(data = untidy2,
             cols = -patient,
             names_prefix = "creatine_",
             names_to = "timepoint",
             values_to = "creatine")
             
```

**C**  

Tidy file [`untidy3.csv`](data/untidy3.csv).

```{r untidy-3-a, eval = FALSE}
untidy3 <- read.table("data/untidy3.csv", 
                      sep = ";", 
                      header = TRUE)
pivot_longer(data = untidy3,
             cols = -species,
             names_sep = "_",
             #OR
             #names_pattern = "(leashed|unleashed)_(caged|free)",
             names_to = c("leashed", "caged"),
             values_to = "wellbeing")
```


### Lung cancer

```{r lung-deaths-to-df-a}
lung_cancer_deaths <- data.frame(year = rep(1974:1979, each = 12),
                     month = rep(month.abb, times = 6),
                     male = as.integer(mdeaths),
                     female = as.integer(fdeaths),
                     total = as.integer(ldeaths))
```


**A**  

```{r tidy-lung-cancer-a}
lung_cancer_deaths <- pivot_longer(data = lung_cancer_deaths, 
             cols = 3:5, 
             names_to = "type",
             values_to = "count")
```

**B**  

Prep:  
```{r lung-deaths-date-column-a}
lung_cancer_deaths$date <- as.Date(x = paste(lung_cancer_deaths$month, lung_cancer_deaths$year, 1, sep="/"),
        format = "%b/%Y/%d")
```

Figure:
```{r lung-deaths-line-plot-a, fig.asp=.75, out.width='70%', fig.align='center'}
ggplot(data = lung_cancer_deaths,
       mapping = aes(x = date, y = count)) +
  geom_line(aes(color = type))
```


**C**

```{r lung-deaths-boxplot-a, fig.asp=.75, out.width='70%', fig.align='center'}
ggplot(data = lung_cancer_deaths,
       mapping = aes(x = type, y = count)) +
  geom_boxplot(aes(fill=type))
```

ANSWER: You can see a single outlier in the `female` set. We can identify the year by finding out when this occurred:

```{r finding-outliers}
maximum <- max(lung_cancer_deaths[lung_cancer_deaths$type == "female", "count"]) ## 1141
lung_cancer_deaths[lung_cancer_deaths$count == maximum, ]
```

So this was February 1976. A quick Google search turned up a pdf document "CDC Influenza Surveillance" that states

> "The 1975-1976 influenza season was noteworthy because of several events. a) An H3N2 influenza virus (A/Victoria/3/75), isolated first in April 1975, caused a wide- spread epidemic late in the influenza season in the United States. Based on pneumonia- and influenza-associated mortality which peaked in February and March 1976, this was the most severe epidemic experienced by the United States since the 1968-1969 Hong Kong epidemic."

([direct link](https://stacks.cdc.gov/view/cdc/287/cdc_287_DS1.pdf))

As you may know, (lung) cancer patients are especially vulnerable for influenza infections.



## Old school data mangling


### Whale selenium 

```{r read-remote-file-1}
whale_sel_url <- "https://raw.githubusercontent.com/MichielNoback/davur1/gh-pages/exercises/data/whale_selenium.txt"
whale_selenium <- read.table(whale_sel_url,
        header = T,
        row.names = 1)
```

**A**    
```{r, eval = FALSE}
apply(X = whale_selenium, MARGIN = 2, FUN = mean)
```

**B**  
```{r, eval = FALSE}
apply(X = whale_selenium, MARGIN = 2, FUN = sd)
```


**C**    
```{r, eval = FALSE}
my.sem <- function(x) {
        sem <- sd(x) / sqrt(length(x))
}
apply(X = whale_selenium, MARGIN = 2, FUN = my.sem)
```

**D**    
```{r whale-selenium-hist, eval=FALSE}
whale_selenium$ratio <- apply(X = whale_selenium, 
            MARGIN = 1, 
            FUN = function(x){
                    x[2] / x[1]
            })
ggplot(data = whale_selenium, 
       mapping = aes(x = ratio)) +
  geom_histogram(bins = 15) +
  labs(x = "Tooth / Liver Selenium ratio", title = "Tooth / Liver Selenium ratios in whales")
```

**E**  
Inline expressions are like this: `r mean(cars$speed)` MpH.



### Urine properties


```{r download-urine-data-2}
urine_file_name <- "urine.csv"
url <- paste0("https://raw.githubusercontent.com/MichielNoback/datasets/master/urine/", urine_file_name)
local_name <- paste0("../", urine_file_name) #specifiy your own folder!
download.file(url = url, destfile = local_name)
```

**A**  
```{r load-urine-data}
urine <- read.table(local_name, 
                     sep = ",",
                     header = TRUE)
```

**B**  
```{r convert-column-r}
names(urine)[2] <- "ox_crystals"
urine$ox_crystals <- factor(urine$ox_crystals, levels = c(0, 1), labels = c("no", "yes"))
```

**C**  
```{r urine-mean-and-sd-1}
mean_sd <- function(x) {
    # returns a named vector
    c("mean" = round(mean(x, na.rm = T), 2), 
      "sd" = round(sd(x, na.rm = T), 2))
}
apply(X = urine[, 3:8], MARGIN = 2, FUN = mean_sd)
```

**D**  
```{r urine-mean-and-sd-2}
aggregate(cbind(gravity, ph, osmo, cond, urea, calc) ~ ox_crystals, 
          data = urine, 
          FUN = function(x) round(mean(x, na.rm = T), 2))
```



## Data mangling with dplyr


### Global temperature revisited

**A** [&#10059;]    

```{r glob-temp-new, eval = FALSE}
f <- "https://raw.githubusercontent.com/MichielNoback/datasets/master/global_temperature/GLB.Ts%2BdSST.csv"
#temp_dat <- readr::read_csv(f)
temp_dat <- read.table(f, sep = ",", header=TRUE, na.strings = "***")
temp_dat <- as_tibble(temp_dat)
```

**B** [&#10059;&#10059;]  

```{r select-low-summer-a, eval = FALSE}
temp_dat %>% 
    filter(JJA < -0.4) %>% 
    pull(Year)
```


**C**  [&#10059;&#10059;]  

```{r select-coldest-a, eval = FALSE}
# coldest
cold <- temp_dat %>% 
    arrange(J.D) %>% 
    select(Year, J.D) %>% 
    slice(1:5)
# warmest
warm <- temp_dat %>% 
    arrange(desc(J.D)) %>% 
    select(Year, J.D) %>% 
    slice(1:5)
# combine
bind_rows(cold, warm)
```

**D** [&#10059;&#10059;]  

```{r select-season-diff-a, eval = FALSE}
temp_dat %>%
    filter(MAM > (JJA+0.2)) %>%
    select(Year, MAM, JJA)
```

**E** [&#10059;&#10059;&#10059;]  

```{r per-decade-temp-a, eval = FALSE}
decade_avg <- temp_dat %>%
    filter(Year > 1969) %>%
    mutate(Decade = paste0(substr(as.character(Year), 1, 3), "0")) %>% # there probably is a better way to do this...
    select(Year, Decade, DJF, MAM, JJA, SON) %>%
    group_by(Decade) %>%
    summarize(across(-Year, mean, na.rm=T))
```


```{r per-decade-temp-barplot-a, eval = FALSE}
decade_avg %>% 
    pivot_longer(cols = -Decade, 
                 names_to = "Season",
                 values_to = "Anomaly") %>%
    mutate(Season = factor(Season, 
                           levels = c("DJF", "MAM", "JJA", "SON"), 
                           labels = c("Winter", "Spring", "Summer", "Autumn"),
                           ordered = TRUE)) %>%
    ggplot(mapping = aes(x = Decade)) +
        geom_bar(aes(weight = Anomaly, fill = Season), position = position_dodge()) +
    theme_classic()
```


**F** [&#10059;&#10059;&#10059;&#10059;]  

```{r warmest-month-sel-a, eval = FALSE}
max_temp <- max(temp_dat[, 2:13], na.rm=T)
temp_dat %>% 
    filter(if_any(Jan:Dec, ~ .x == max_temp)) %>% #across is deprecated
    select(Year, J.D, where(~ mean(.x, na.rm=T) == max_temp))
```



### Pigs

**A** [&#10059;]    

```{r pigs-load-a, eval = FALSE}
pigs <- read.table("https://raw.githubusercontent.com/MichielNoback/datasets/master/pigs/dietox.csv", 
                   header = TRUE, 
                   sep = ",")

head(pigs)
```

**B** [&#10059;&#10059;]  

```{r pigs-selection-a, eval=FALSE}
pigs %>%
    filter(Time == 12 & Evit == 3 & Cu == 3) %>%
    select(Pig, Litter, Feed, Weight) %>%
    arrange(desc(Weight))
```

**C** [&#10059;&#10059;]  

```{r pigs-exp-setup, eval = FALSE}
pigs %>% 
    distinct(Evit, Cu)
```


**D** [&#10059;&#10059;&#10059;]  

```{r pigs-summarize-weight-a, eval = FALSE}
pigs %>%
    filter(Time == 12) %>%
    group_by(Evit) %>%
    summarize(mean_weight = mean(Weight),
              n = n())
```

**E** [&#10059;&#10059;&#10059;]  

```{r pigs-weigh-gain-a, eval = FALSE}
gain <- pigs %>%
    select(Pig, Time, Weight, Feed, Evit, Cu) %>%
    group_by(Pig) %>%
    mutate(Cu = factor(Cu),
           Evit = factor(Evit),
           Lag_Weight = lag(Weight),
           Gain = (Weight - Lag_Weight)/Lag_Weight*100) 

ggplot(gain, aes(x = Cu, y = Gain, color = Cu)) +
    geom_violin() +
    facet_wrap(~Evit)
```

**F** [&#10059;&#10059;&#10059;]  

```{r pigs-wide-a, eval = FALSE}
# select and pivot
pigs %>% 
    select(-X) %>%
    pivot_wider(names_from = Time,
                names_prefix = "w_",
                values_from = c(Weight, Feed))
```


### Population numbers

**A** [&#10059;]

```{r population-1, eval = FALSE}
pop_data_file <- "https://raw.githubusercontent.com/MichielNoback/datasets/master/population/EDU_DEM_05022020113225751.csv"
population <- read.table(pop_data_file,
                         header = TRUE, 
                         sep=",")
```

**B** [&#10059;&#10059;]  
**Which?**
`str(population)` tells me that `Unit.Code`, `Unit` and `PowerCode` are factors with one level. Using `table(population$PowerCode.Code, useNA = "always")` tells me that there are only zeros there. Same for `Reference.Period.Code` and `Reference.Period`. The variables `Flags` and `Flag.Codes` refer to the same, so one of them can be removed (I choose to remove `Flag.Codes`). The same counts for `SEX`/`Sex`, `AGE`/`Age` and `YEAR`/`Year`.

**Select**
This is my selection:

```{r population-2, eval = FALSE}
keep <- names(population)[c(1, 2, 4, 6, 8, 15, 16)]
keep
population <- as_tibble(population[, keep]) #tibble is nicer!
head(population)
```

**C** [&#10059;&#10059;&#10059;] 

```{r wide-population-repost, eval = FALSE}
pop_totals <- dplyr::filter(population, Sex == "Total" & Age == "Total: All age groups")
##or, using base R
#population[population$Sex == "Total" & population$Age == "Total: All age groups", ]
pivot_wider(
    data = pop_totals[, c(1, 2, 5, 6)],
    names_from = Year,
    values_from = Value)

```

**D** [&#10059;&#10059;&#10059;&#10059;]  
You could do this on the `pop_totals` dataset using the `lag()` function, after using `group_by()`, but since we have the wide format, you could also use a simple `for` loop, iterating the columns by index and subtracting the first from the second. I will demonstrate the only the first.

```{r pop-change-wide-report, eval = FALSE}
pop_totals %>% 
    group_by(Country) %>%
    mutate(Pop_change = as.integer(Value - lag(Value))) %>%
    ungroup() %>%
    select(-Value) %>%
    pivot_wider(names_from = Year,
        values_from = Pop_change) %>%
    select(-`2005`, -`2010`, -Flag.Codes) 
## backticks in above selection are required 
## because we are selecting names that are numbers!
```

**E** [&#10059;&#10059;&#10059;]  
```{r pop-barplot, eval=FALSE}
sel <- population %>%
    filter(Sex == "Women" | Sex == "Men") %>%
    filter(COUNTRY %in% c("BEL", "CHE", "DNK", "FRA", "IRL", "DEU", "LUX", "NLD", "GBR")) %>%
    drop_na()

ggplot(sel, mapping = aes(Year)) +
    geom_bar(aes(weight = Value, fill = Sex))  + 
    facet_wrap(. ~ COUNTRY)

```

**F** [&#10059;&#10059;&#10059;&#10059;]  
```{r pop-fastest-growth-rate, eval = FALSE}
population %>%
    filter(Sex == "Total" & Age == "Total: All age groups" & (Year == 2005 | Year == 2017)) %>%
    group_by(Country) %>%
    mutate(Change = Value - lag(Value), 
           Previous = lag(Value)) %>%
    mutate(GrowthRate = Change / Previous * 100) %>%
    ungroup() %>%
    select(COUNTRY, Country, GrowthRate ) %>%
    arrange(desc(GrowthRate)) %>%
    head(3)
```




## Text processing with regex


### Restriction enzymes

**A** [&#10059;&#10059;]    
```{r resenz-1, eval = FALSE}
pacI_re <- "TTAATTAA"
patterns <- c("T{2}A{2}T{2}A{2}",
           "(TTAA){2}",
           "(T{2}A{2}){2}")
for(ptrn in patterns){
    print(grepl(ptrn, pacI_re))
}
```

**B** [&#10059;&#10059;]    
```{r resenz-2, eval = FALSE}
sfiI_re <- "GGCCACGTAGGCC"
patterns <- c("G{2}C{2}[GATC]{5}G{2}C{2}",
           "GGCC[GATC]{5}GGCC",
           "[GC]{4}[GATC]{5}[GC]{4}") #last one is less specific!
for(ptrn in patterns){
    print(grepl(ptrn, sfiI_re))
}
```

### Prosite Patterns

**A** [&#10059;&#10059;]    
PS00211:
"[LIVMFYC]-[SA]-[SAPGLVFYKQH]-G-[DENQMW]-[KRQASPCLIMFW]-[KRNQSTAVM]-[KRACLVM]-[LIVMFYPAN]-{PHY}-[LIVMFW]-[SAGCLIVP]-{FYWHP}-{KRHP}-[LIVMFYWSTA]."

```{r prosite-1, eval = FALSE}
PS00211<- "[LIVMFYC][SA][SAPGLVFYKQH]G[DENQMW][KRQASPCLIMFW][KRNQSTAVM][KRACLVM][LIVMFYPAN][^PHY][LIVMFW][SAGCLIVP][^FYWHP][^KRHP][LIVMFYWSTA]"
```

**B** [&#10059;&#10059;]    
PS00018:
"D-{W}-[DNS]-{ILVFYW}-[DENSTG]-[DNQGHRK]-{GP}-[LIVMC]-[DENQSTAGC]-x(2)- [DE]-[LIVMFYW]."

```{r prosite-2, eval = FALSE}
PS00018 <- "D[^W][DNS][^ILVFYW][DENSTG][DNQGHRK][^GP][LIVMC][DENQSTAGC].{2} [DE][LIVMFYW]"
```


### Fasta Headers

```{r stringr-fasta-1, eval = FALSE}
library(stringr)
fasta_headers <- readLines("./data/fasta_headers.txt")
```

**A** [&#10059;&#10059;&#10059;]  
```{r stringr-fasta-2, eval = FALSE}
str_match(fasta_headers, "\\[(.+)\\]")[, 2]
str_match(fasta_headers, "\\[([[:alpha:]]+ [[:alpha:]]+) ?(.+)?\\]")[, 2]
```

**B** [&#10059;&#10059;&#10059;]  
```{r stringr-fasta-3, eval = FALSE}
str_match(fasta_headers, ">([[:alpha:]]{2,3}\\|\\w+)\\|")[, 2]
```

**C** [&#10059;&#10059;&#10059;]  
```{r stringr-fasta-4, eval = FALSE}
str_match(fasta_headers, ">.+\\| (.+?) \\[")[, 2]
```

## Package ggplot2 revisited


### Eye colors

**A** [&#10059;&#10059;]  

```{r eyecolors-load-data-a, eval=FALSE}
(ec_data <- readr::read_csv("data/eyecolor_data.csv", 
                            col_types = "cfiffffffff",
                            na="-"))
```

**B** [&#10059;&#10059;&#10059;]  

```{r eyecolors-recode-a, eval = FALSE}
ec_data <- ec_data %>%
    mutate(across(4:11, ~ recode_factor(.x, blauw = "blue", bruin = "brown", groen = "green")))

```

**C** [&#10059;&#10059;&#10059;&#10059;]  

```{r eyecolors-majority-a, eval = FALSE}
## Majority for use in mutate()
majority <- function(x) {
    #print(as.character(x))
    # there are many other approaches to be taken
    t <- table(x)
    if (length(t) == 1) return(x[1]) # one entry = no problem
    else if(length(unique(t)) == 1) return("intermediate") # same counts = no majority
    else{
        # order by count and return the most abundant one
        df <- as.data.frame(t)
        return(as.character(df[order(df$Freq, decreasing = T)[1], 1]))
    }
}

# mutate to apply the function
# this requires rowwise() and c_across()
ec_data <- ec_data %>%
    rowwise() %>%
    mutate(majority = majority(c_across(-(1:3))))
```

**D** [&#10059;&#10059;&#10059;]  

```{r eyecolors-pivot-longer-a, eval = FALSE}
ec_data_tidy <- ec_data %>%
    pivot_longer(cols = -c(Identifier, sex, age, majority),
                 names_sep = "_",
                 names_to = c("eye", "experimenter"),
                 values_to = "observed_color")
```

**E** [&#10059;&#10059;&#10059;]  

```{r eyecolors-balloon-a, eval = FALSE}
## create the contingency table
counts <- ec_data_tidy %>% select(sex, eye, observed_color) %>%
    group_by(sex, eye, observed_color) %>%
    summarize(count = n(), .groups = "drop") 

## The balloon plot. Not that quotes around variables are required!
ggpubr::ggballoonplot(data = counts, 
                      x = 'eye', 
                      y = 'observed_color', 
                      facet.by = 'sex', 
                      size = 'count',
                      fill = "blue")
```

## Working with date-time data

### Bacterial growth

**A** [&#10059;&#10059;]  

```{r bact-growth-read, eval=FALSE}
bact_growth <- read.table('data/growth-exp-data.csv', 
           sep = ";",
           header = TRUE)
```

**B** [&#10059;&#10059;]  

```{r bact-growth-unite, eval=FALSE}
bact_growth <- bact_growth %>%
    unite(date_time, date, time, sep="@") %>%
    mutate(date_time = lubridate::dmy_hm(date_time))
```

**C** [&#10059;&#10059;&#10059;]  

```{r bact-growth-hours, eval=FALSE}
start <- bact_growth$date_time[1]
bact_growth <- 
    bact_growth %>%
    mutate(elapsed_time = hour(seconds_to_period(date_time - start)))
```


**D** [&#10059;&#10059;&#10059;]  

```{r bact-growth-plot, eval=FALSE}
# Value used to transform the data of the second axis
coeff <- 1

OD_color <- "#69b3a2"
glucose_color <- "deepskyblue3"
ggplot(data = bact_growth, mapping = aes(x=elapsed_time)) +
  geom_line(mapping = aes(y = OD600), linewidth = 1, color = OD_color) + 
  geom_line(mapping = aes(y=glucose / coeff), linewidth = 1, color = glucose_color) +
  scale_y_continuous(
    # Features of the first axis
    name = "OD600",
    # Add a second axis and specify its features
    sec.axis = sec_axis(~ . * coeff, name = "Glucose level")
  ) +
  xlab("elapsed time (h)") +
  theme_classic() +
  theme(
    axis.title.y = element_text(color = OD_color, size=13),
    axis.title.y.right = element_text(color = glucose_color, size=13)
  )
```

